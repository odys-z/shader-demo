<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>07.5 SDF Terrian Mileston 2</title>
    <link rel='stylesheet' type='text/css' href='../lib/shader.css'>
    <script type='text/javascript' src='three.js/three.min.js'></script>
    <script type='text/javascript' src='three.js/OrbitControls.js'></script>
    <script type='text/javascript' src='../lib/volumetric-raymatching v0.1.js'></script>
  </head>
  <body>
    <p>7.5 SDF Terrian Mileston 2<br>
			Using partial derivative to get terrian norm. (dx, dy = 0.001, 0.001)</p>
    <canvas id="frag"></canvas>
  </body>
<script>
'use strict';

const fragmentShader = `
  uniform vec3 iResolution;
  uniform vec3 camPos;
  uniform float iTime;
  uniform vec2 iMouse;
  /** [texture-w, texture-h, world-w, world-h] */
  uniform vec4 texize;
  uniform sampler2D iChannel0;

  varying vec2 vUv;
  varying vec3 I;
  varying vec3 P;
  varying vec4 cent;

  //
  const float PI = 3.14159265359;
  const float DEG_TO_RAD = PI / 180.0;
  const float hscale = 1.;

  // dx, dy in texture uv [0, 1]
  const vec2 dxdz = vec2(0.01);

  /** get ray direction in world
   * input: varying P, world postion of the pixel:
   * modelMatrix * vec4(position, 1.0);
   * @param eye ray origin
   * @return dir norm
   */
  vec3 ray_dir( vec3 eye ) {
	return normalize(P - eye);
  }

  /**
   * @param xz world postion (x, 0, z), will be normalized with texize.wz
   * @return height  (length of pixel color)
   */
  float textureHight (vec2 xz) {
	vec2 uv = xz / texize.zw + 0.5;
	return length(texture2D(iChannel0, uv - vec2(dxdz.x, 0.0))) * hscale;
  }

  /** Trace the ray through the scene
   * http://2008.sub.blue/blog/2009/3/7/tracing_a_terrain.html
   * @param eye Current position of marching ray
   * @param rd Ray direction
   * @param t max distance
   * @return vec2 [ distance, height ]
   */
  vec2 castRay( in vec3 eye, in vec3 rd, in float t) {
    float ray_distance;
    float surface = 0.0;

    float max_d = t;
    float dt = .1;                   // Step size
	t = dt;
    float prev_alt = eye.y;
    vec3  ray = eye;
    vec3  basic_ray = eye;
	vec3  prev_ray = eye;

    // March ray until we reach the horizon
    for (float ix = 0.0; ix < 4000.0; ix ++) {
        ray_distance = -1.0;          // < 0 when no intersection

        // Vector for current position
        ray += rd * t;

        // If greater than the max terrain height and moving away from the plane then stop
        // if (ray.y > 100.0 && ray.y > prev_ray.y && t > max_d)
        if (ray.y > 100.0 && ray.y > prev_ray.y && t > max_d)
            break;

        // Find terrain displacement for the current point
        // surface = displacement(ray);
        surface = textureHight(ray.xz);

        if (ray.y <= surface) {
            // Interpolate the intersection distance
            float id = (prev_alt - prev_ray.y) / (ray.y - prev_ray.y - surface + prev_alt);
            ray_distance = mix(t, (t - dt), id);
            surface = mix(surface, ray.y, id);
            ray.y = surface;
            prev_ray.y = prev_alt;
            break;
        }

        // Step size increases proportionally to the ray length
        t += dt;
        // 0.01: terrainHorizon
        // if ( t < 0.01 )
        //   break;
		if (t > max_d)
			break;

        dt = min((t - max_d), 0.005);
        prev_alt = surface;
        prev_ray = ray;
    }

    return vec2(ray_distance, surface);
    // return vec2(sin(iTime) + 1., surface);
    // return vec2(sin(rd.x) + 1., surface);
  }

  /** Get distance of eye to intersect with horizon.
   * The line = e + rd * t;
   * where t is the scale.
   * When (e + rd * t).y == 0, t define the distance.
   * t = - e.y / rd.y
   * d = dot(rd * t) ^ 0.5 (if rd is normalized, d == t)
   * @param e eye postion in world
   * @param rd ray direction, in world
   * @return vec4 [intersect-point, distance]
   */
  vec4 horizonDist(vec3 e, vec3 rd) {
	rd = normalize(rd);
	if (rd.y == 0.0)
		return vec4(-1.0);

    float t = -e.y / rd.y ;

	// must hit terrian represented by the texture0
	vec3 p = e + rd * t;

	// terrian texture AABB
	vec2 range = texize.zw * 0.5;
	if (p.x < -range.x || p.x > range.x || p.z < -range.y || p.z > range.y)
		return vec4(-.1);

	// let's rock - raymaching backward
	vec2 hit = castRay( e, rd, t);
	return vec4(e + rd * hit.x, hit.x);
  }

  vec3 gradient (vec3 e, vec3 pos) {
	vec3 dx = vec3(0.01, 0., 0.);
	vec3 dy = vec3(0., 0.01, 0.);
	vec3 dz = vec3(0., 0., 0.01);
	float pdx = horizonDist(e, pos + dx).w - horizonDist(e, pos - dx).w;
	float pdy = horizonDist(e, pos + dy).w - horizonDist(e, pos - dy).w;
	float pdz = horizonDist(e, pos + dz).w - horizonDist(e, pos - dz).w;
	return vec3(pdx, pdy, pdy);
  }

  /**Raymatching to terrian heights,
   * where terrian height is represented in 2D texture iChannel0.
   * @param eye ray origin
   * @param rd ray direction
   * @return vec4 if hit, [position, dist]; or [rd, -1.];
   */
  vec4 terrian( vec3 eye, vec3 rd ) {
    vec4 dist = horizonDist(eye, rd);

	float hdx = 0.;
	float hdz = 0.;
	if (dist.w >= 0.0) {
		// vec3 dh = textureNorm(dist.xz);
		vec3 p = eye + rd * dist.w;
		return vec4(p, dist.w);
	}
	else
    	return vec4(rd, dist.w);
  }

  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    // SDF tanslate
    vec3 e = camPos;
    e.y += 0.5;
    vec3 i = ray_dir( camPos );
    vec4 dists = terrian( e, i );

    if (dists.w < 0.0) {
      // Didn't hit anything
      fragColor = vec4(abs(i), 1.);
      return;
    }

    // vec3 pos = camPos + i * dists.w;

	// vec2 uv = vec2(dists.xz / texize.zw) + 0.5;
	// fragColor = mix(
	// 			vec4(gradient(e, dists.xyz), 1.0),
	// 			texture2D( iChannel0, clamp(uv, 0., 1.) ),
	// 			0.1);
	fragColor = vec4(gradient(e, dists.xyz), dists.w * .2);
  }

  void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
  }
`;

const vertexShader = `
  uniform vec3 camPos;

  varying vec2 vUv;
  varying vec3 I;
  varying vec3 P;
  varying vec4 cent;

  void main() {
    vUv = uv;

    // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);

    P = worldPosition.xyz;
    I = normalize(camPos - worldPosition.xyz);

    cent = modelMatrix * vec4(0., 0., 0., 1.);

    gl_Position = projectionMatrix * viewMatrix * worldPosition;
  }
`;

  const campos = new THREE.Vector3(0, 0.2, 2.6);
  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');

  var texture;
  texture = sinText(64, 64);

  const uniforms = {
    iTime: { value: 0 },
		// texize.xy = texture-size, texize.zw = world.xz represented
    texize: { value: new THREE.Vector4(64, 64, 4, 4) },
    iResolution:  { value: new THREE.Vector3() },
    camPos: { value: campos },
    iChannel0: { value: texture },
    // iChannel0: { value: texture },
    iMouse: {value: new THREE.Vector2()},
  };

  //const mouse = new THREE.Vector2();
  document.onmousemove = function(e){
    uniforms.iMouse.value.x = e.clientX / window.innerWidth - 0.5;
    uniforms.iMouse.value.y = e.clientY / window.innerHeight - 0.5;
  }

  vmatch('frag', vertexShader, fragmentShader, uniforms,
    // {geometryType: new THREE.BoxGeometry(.6, .6, .6),
    {geometryType: new THREE.PlaneGeometry(2.0, 3.2),
     camPos: { value: campos },
     geometryCnt: 3});
</script>
</html>
